#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

// ссылка на задачу: https://www.codingame.com/ide/puzzle/death-first-search-episode-1

using namespace std;

int main()
{
    int n; // общее число нодов (включая гейты-выходы)
    int l; // общее число связей между нодами (включая гейты-выходы)
    int e; // число гейтов-выходов
    int gateway[20]; // массив индексов нодов, являющихся гейтами-выходами
    vector<vector<int>> network; // матрица смежности графа
    
    cin >> n >> l >> e; cin.ignore();
    network.reserve(n); // выделяем достаточное количество памяти для n-элементов матрицы смежности (строки)

    for (int t = 0; t < n; t++)
    {   
        network[t].reserve(n); // выделяем достаточное количество памяти для n-элементов матрицы смежности (столбцы)
        for (int v = 0; v < n; v++)
        {
            network[t].push_back(0); // заполняем каждый столбец нулями
        }
    }
    for (int i = 0; i < l; i++) {
        int n1; // введенные числа обозначают наличие связи между нодами n1 и n2
        int n2;
        cin >> n1 >> n2; cin.ignore();

        network[n1][n2] = 1; // работаем над матрицей смежности, отмечая соединенные ноды
        network[n2][n1] = 1;
    }

    for (int i = 0; i < e; i++) {
        int ei; // введенные числа обозначают индексы нодов, являющихся гейтами-выходами
        cin >> ei; cin.ignore();
        gateway[i] = ei;
    }

    // По условию задачи каждый нод может быть соединен только с одним гейтом-выходом,
    // а значит достаточно проверять глубину в 1 связь для устранения соединения с гейтом-выходом

    while (1) {

        int si; // введенное число обозначает индекс нода, на котором находится противник
        cin >> si; cin.ignore();
        int goal; // индекс целевого нода
        bool finded = false; // флаг, отмечающий нахождение гейта-выхода среди соседей нода
        for(int i = 0; i < e; i++) // в цикле проверяем каждый гейт-выход на соседство с si-нодом
        {
            goal = gateway[i];
            if (network[goal][si] == 1)
            {
                finded = true; // если найден гейт-выход, устанавливаем флаг
                network[goal][si] = 0; // удаляем существующие связи из матрицы смежности
                network[si][goal] = 0;
                break; // и выходим из цикла
            }
        }
        if (!finded) // в ином случае
        {
            for (int i = 0; i < n; i++) // пробегаемся уже по всему столбцу si-нода и ищем существующих соседей
            {   
                if(network[i][si] == 1)
                {
                    goal = i; // если найден нод-сосед, выбираем его целью
                    network[i][si] = 0; // удаляем связи из матрицы
                    network[si][i] = 0;
                    break; // и выходим из цикла
                } // иных вариантов нет, т.к. если у нода нет соседей, то мы уже победили по условию задачи
            }
        }

        cout << goal << ' ' << si << endl;
    }
}